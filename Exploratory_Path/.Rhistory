# if not, then move for 1/2
# if difference < 0, it indicates that the scale should increase
if (current >0){
from<-now
now <- (now + to)/2
}else{
# else, then the scale should decrease
to<-now
now <- (from + now)/2
}
# if iteration > max_iteration, stop
if (iteration >= max_iter){
break
}
}
# return iteration # and result
# if convergence failed then return -1
if (iteration >= max_iter){
return (-1)
}else{
return(now)
}
}
correct_scale<-function(filename_mask = 'mask.nii'){
# read mask file
MaskImg <- readNIfTI(filename_mask)
MaskImgData = oro.nifti::img_data(MaskImg)
# get mask size image
X <- dim(MaskImg)[1]
Y <- dim(MaskImg)[2]
Z <- dim(MaskImg)[3]
# let's count non-zero and non-nan voxel number
count <- 0
for (i in 1:X){
for (j in 1:Y){
for (k in 1:Z){
if ((MaskImgData[i,j,k] != 0) && !(is.nan(MaskImgData[i,j,k])) ){
# non zero and non nan -> count
count <- count + 1
}
}
}
}
# get combination (to find the # of comparison groups)
# find m where mC2 = total voxel number
# start from 2
config_scale <- .707
config_alpha <- .05
now <- 2
while(1){
# calculate current combination
combination <- now * (now-1)/2
# combination >= count (non-zero non-nan voxel #?)
if (combination >= count){
break
}
# the goal not achieved, then, increase 1
now <- now + 1
}
# finalize group number
Group <- now
# then, p(H01) = p(H0)^(2/m) where m = Group
# calculate the corrected threshold value
# .95 ^ (2/Group)
corr_p <- (1-config_alpha)^(2/Group)
# time to look for Cauchy distribution scale SCALE_NEW that satisfies
# pcauchy(qcauchy(.95,scale=.707), SCALE_NEW) = corr_p
default_point <- qcauchy((1-config_alpha),scale=config_scale)
# set desired precision
# default = (1-corr_p) / 10
precision <- (1-corr_p) / 10
# starting from the default scale .707
scale_default <- config_scale
scale_current <- scale_default
scale_previous <- scale_default
trial <- 1
while(1)
{
# until the precision is achieved...
# if first trial,
if (trial == 1)
{
# starting from the half of the default scale
scale_current <- scale_default / 2.0
# calculate the current culumative pdf at default_point
current_cpdf <- pcauchy(default_point, scale= scale_current)
# calculate difference
diff <- abs(corr_p - current_cpdf)
# diff <= precision?
if (diff <= precision){
# stop here
break
}
# if not, trial <- trial + 1
trial <- trial + 1
# and also find the dirrection
if ((corr_p - current_cpdf) > 0)
{
# scale_current should be decreased, so right direction
direction <- -1
}
else
{
# scale_current should be increased, so let's tweak it
direction <- 1
}
}
else{
# if not the first trial...
# find the distance between current and previous scale
distance <- abs(scale_current - scale_previous)
# then, set the current scale as start_point + distance /2 * direction
# also, update the previous scale
scale_previous <- scale_current
scale_current <- scale_current + distance / 2.0 * direction
# calculate the current culumative pdf at default_point
current_cpdf <- pcauchy(default_point,scale= scale_current)
# calculate difference
diff <- abs(corr_p - current_cpdf)
# diff <= precision?
if (diff <= precision){
# stop here
break
}
# if not, trial <- trial + 1
trial <- trial + 1
# and also find the dirrection
if ((corr_p - current_cpdf) > 0)
{
# scale_current should be decreased, so right direction
direction <- -1
}
else
{
# scale_current should be increased, so let's tweak it
direction <- 1
}
}
}
# found current scale!
# let's use this scale for cauchy prior distribution
return(scale_current)
}
adjust_cauchy_scale(4.7854359796610275,1.5598297650412472,0.05145979448703311)
adjust_cauchy_scale(2.337460017950926,0.09000875833726335,0.20115387840324436)
adjust_cauchy_scale(5.2238155142807825,2.337460017950926,0.09000875833726335)
load("~/Documents/GitHub/COVIDiSTRESS2_Stress/Stress_aligned.RData")
table(data.filtered$residing_country)
length(table(data.filtered$residing_country))
load("~/Documents/GitHub/COVIDiSTRESS2_Stress/Stress_aligned.RData")
length(table(data$residing_country))
length(table(data$UserLanguage))
length(table(data.mi$residing_country))
length(table(data.mi$UserLanguage))
length(table(data.filtered$residing_country))
length(table(data.filtered$UserLanguage))
load("~/Documents/GitHub/COVIDiSTRESS2_Stress/Stress_aligned.RData")
table(data$gender)
10558+5009+163
load("~/Documents/GitHub/COVIDiSTRESS2_Stress/Stress_aligned.RData")
colnames(data)
head(data[,88:104])
psych
library(psych)
psych::alpha(data[,88:95])
testmodel <- 'SI ~= socialinfluence_nor1_1 + socialinfluence_nor1_2'
testcfa(testmodel,data)
testcfa<-cfa(testmodel,data)
library(lavaan)
testcfa<-cfa(testmodel,data)
testmodel <- 'SI =~ socialinfluence_nor1_1 + socialinfluence_nor1_2'
testcfa<-cfa(testmodel,data)
testmodel <- 'SI =~ socialinfluence_nor1_1 + socialinfluence_nor1_2+socialinfluence_nor1_3+socialinfluence_nor1_4+socialinfluence_nor1_5+socialinfluence_nor1_6+socialinfluence_nor1_7+socialinfluence_nor1_8'
testcfa<-cfa(testmodel,data)
library(semTools)
runMI
test<-cfa.mi(testmodel,data = )
test<-cfa.mi(testmodel,data)
install.packages('Amelia')
test<-cfa.mi(testmodel,data)
test<-cfa.mi(testmodel,data,m=20)
head(data[,88:104])
testset<-data[,88:104]
head(testset)
testset<-data[,88:95]
head(testset)
test<-cfa.mi(testmodel,testset,m=20)
test
head(test@Data)
test@Data
test@Data@group
test<-cfa.mi(testmodel,testset,m=20,groups='UserLanguage')
test<-cfa.mi(testmodel,testset,m=20,group='UserLanguage')
test<-cfa.mi(testmodel,testset,m=20,miArgs = list(cs = "UserLanguage"))
testset<-data.filtered[,88:95]
head(testset)
test<-cfa.mi(testmodel,testset,m=20,miArgs = list(cs = "UserLanguage"))
testset<-data.filtered[,c(88:95,'UserLanguage')]
testset<-cbind(data.filtered[,c(88:95)],data.filtered$UserLanguage)
head(testset)
testset<-data.filtered[,c(88:95,'UserLanguage')]
test<-cfa.mi(testmodel,testset,m=20,miArgs = list(cs = "UserLanguage"))
class(testset)
test<-cfa.mi(testmodel,testset,m=20,miArgs = list(cs = "UserLanguage"))
test<-cfa.mi(testmodel,testset,m=20,miArgs = list(cs = "data.filtered$UserLanguage"))
test
summary(test)
fitMeasures(test)
test<-cfa.mi(testmodel,testset,estimator='WLSMV'm=20,miArgs = list(cs = "data.filtered$UserLanguage"))
test<-cfa.mi(testmodel,testset,estimator='WLSMV',m=20,miArgs = list(cs = "data.filtered$UserLanguage"))
fitMeasures(test)
test@Data@missing
summary(test@Data)
testamelia <- amelia(testset,m=20,cs='UserLanguage')
testamelia <- amelia(testset,m=20,cs='data.filtered$UserLanguage')
imps<-testamelia$imputations
head(imps)
head(testamelia$imputations$imp1)
head(testamelia$imputations$imp2)
AmeliaView()
a.out <- transform(testamelia)
head(a.out)
install.packages("Zelig")
load("~/Documents/GitHub/Identity-Project/Identity_aligned.RData")
testset<-data.filtered[,c(88:95,'UserLanguage')]
testset<-cbind(data.filtered[,c(88:95)],data.filtered$UserLanguage)
colnames(testset)
colnames(data.filtered)
testset<-cbind(data.filtered[,c(89:96)],data.filtered$UserLanguage)
testamelia <- amelia(testset,m=20,cs='data.filtered$UserLanguage')
for (i in 20){}
for (i in 20){
i<-1
tempdata <- cbind(testamelia$imputations[[i]],data.filtered$CS)
head(tempdata)
colnames(tempdata)[10] <- 'CS'
tempdata <- tempdata[,c(1:8,10)]
head(tempdata)
for (i in 20){
tempdata <- cbind(testamelia$imputations[[i]],data.filtered$CS)
colnames(tempdata)[10] <- 'CS'
tempdata <- tempdata[,c(1:8,10)]
ols.out <- lm(CS ~. , data=tempdata)
}
ols.out
summary(ols.out)
b.out <- NULL
se.out <- NULL
ols.out$coefficients
coef(summary(ols.out))[,2]
for (i in 20){
tempdata <- cbind(testamelia$imputations[[i]],data.filtered$CS)
colnames(tempdata)[10] <- 'CS'
tempdata <- tempdata[,c(1:8,10)]
ols.out <- lm(CS ~. , data=tempdata)
b.out <- rbind(b.out,ols.out$coefficients)
se.out <- rbind(se.out, coef(summary(ols.out))[,2])
}
b.out
se.out
for (i in 1:20){
tempdata <- cbind(testamelia$imputations[[i]],data.filtered$CS)
colnames(tempdata)[10] <- 'CS'
tempdata <- tempdata[,c(1:8,10)]
ols.out <- lm(CS ~. , data=tempdata)
b.out <- rbind(b.out,ols.out$coefficients)
se.out <- rbind(se.out, coef(summary(ols.out))[,2])
}
b.out
se.out
b.out <- NULL
se.out <- NULL
for (i in 1:20){
tempdata <- cbind(testamelia$imputations[[i]],data.filtered$CS)
colnames(tempdata)[10] <- 'CS'
tempdata <- tempdata[,c(1:8,10)]
ols.out <- lm(CS ~. , data=tempdata)
b.out <- rbind(b.out,ols.out$coefficients)
se.out <- rbind(se.out, coef(summary(ols.out))[,2])
}
combined.results <- mi.meld(q=b.out,se=se.out)
combined.results
testmodel
testmodel<-'
S1 =~ socialinfluence_nor1_1+socialinfluence_nor1_2+socialinfluence_nor1_3+
socialinfluence_nor1_4+socialinfluence_nor1_5+socialinfluence_nor1_6+
socialinfluence_nor1_7+socialinfluence_nor1_8
'
configural <- cfa.mi(testmodel,testset,group='data.filtered$UserLanguage',
estimator='WLSMV',m=20,seed=12345,
miArgs = list(noms = "data.filtered$UserLanguage"))
configural
summary(configural)
fitMeasures(configural)
configural <- cfa.mi(testmodel,testset,group='data.filtered$UserLanguage',
estimator='WLSMV',m=20,seed=12345
)
colnames(testset)
configural <- cfa.mi(testmodel,testset,group='data.filtered$UserLanguage',
estimator='WLSMV',m=20,seed=12345,
miArgs = list(x = testset[,1:8])
)
ameliadata <- amelia(testset,m=20,seed=12345,cs='data.filtered$UserLanguage')
configural <- cfa.mi(testmodel,ameliadata$imputations,group='data.filtered$UserLanguage',
estimator='WLSMV',m=20,seed=12345
)
configural <- cfa.mi(testmodel,ameliadata$imputations,group='data.filtered$UserLanguage',
estimator='MLR',m=20,seed=12345
)
fitmeasures(configural)
Fitmeasures(configural)
fitMeasures(configural)
fitMeasures(configural,test = "D2" , pool.robust = TRUE)
metric <- cfa.mi(testmodel,ameliadata$imputations,group='data.filtered$UserLanguage',
estimator='MLR',m=20,seed=12345, group.equal='loadings'
)
fitMeasures(configural,test = "D2" , pool.robust = TRUE)
fitMeasures(metric,test = "D2" , pool.robust = TRUE)
fitMeasures(metric)
scalar <- cfa.mi(testmodel,ameliadata$imputations,group='data.filtered$UserLanguage',
estimator='MLR',m=20,seed=12345, group.equal=c('loadings',
'intercepts')
)
fits.scalar<-fitMeasures(scalar)
fits.scalar
test <- plausibleValues(scalar)
test
test<-lavPredict(scalar)
scalar
summary(scalar)
class?lavaan.mi
test<-fitted(scalar)
test
test$EN
test<-fitted.values(scalar)
test
test <- plausibleValues(scalar)
test
test[[1]]
head(test[[1]])
head(test[[2]])
head(test[[3]])
head(test[[4]])
head(test[[5]])
head(test[[20]])
save.image("~/Documents/Research/Collaborations/COVID/Social_Norms/test.RData")
load("~/Documents/GitHub/COVIDiSTRESS2_Vaccine/Vaccine_H2.RData")
library(lmerTest)
library(brms)
library(EMAtools)
bayestestR::mediation(med_result)
med_result
bayestestR::mediation(med_result)
test<-bayestestR::mediation(med_result)
test$Estimate
test$Effect
.219-.123
load("~/Documents/GitHub/COVIDiSTRESS2_Vaccine/Vaccine_H3.RData")
med3_result
bayestestR::mediation(med3_result)
citation(package = "base", lib.loc = NULL, auto = NULL)
setwd("~/Documents/GitHub/COVIDiSTRESS2_Vaccine/Exploratory_Path")
# alt model test
library(lmerTest)
library(brms)
library(EMAtools)
library(psych)
library(bayestestR)
# load aligned data
load((file='../Vaccine_H2.RData'))
load((file='../Vaccine_H3.RData'))
# simultaneous path model
prior.coef <- brms::prior(cauchy(0.,1),class='b')
model_mediator1 <- bf(consp~trust6 + trust7+ gender + education + work_location + age+
SSS_faml+ relationship_status + (1+trust6 + trust7|residing_country))
model_mediator2 <- bf(anti~trust6 + trust7 + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+trust6 + trust7|residing_country))
model_outcome <- bf(vx ~ anti+consp+trust_6+trust_7 + gender + education + work_location + age+
SSS_faml+ relationship_status+ (1+trust_7+anti+trust_6+consp|residing_country))
# simultaneous path model (original)
model_mediator1o <- bf(trust_7~consp+anti + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+anti+consp|residing_country))
model_mediator2o <- bf(trust_6~consp+anti + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+anti+consp|residing_country))
model_outcomeo <- bf(vx ~ anti+consp+trust_6+trust_7 + gender + education + work_location + age+
SSS_faml+ relationship_status+ (1+trust_7+anti+trust_6+consp|residing_country))
# alt model test
library(lmerTest)
library(brms)
library(EMAtools)
library(psych)
library(bayestestR)
# load aligned data
load((file='../Vaccine_H2.RData'))
load((file='../Vaccine_H3.RData'))
# simultaneous path model
prior.coef <- brms::prior(cauchy(0.,1),class='b')
model_mediator1 <- bf(consp~trust6 + trust7+ gender + education + work_location + age+
SSS_faml+ relationship_status + (1+trust6 + trust7|residing_country))
model_mediator2 <- bf(anti~trust6 + trust7 + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+trust6 + trust7|residing_country))
model_outcome <- bf(vx ~ anti+consp+trust_6+trust_7 + gender + education + work_location + age+
SSS_faml+ relationship_status+ (1+trust_7+anti+trust_6+consp|residing_country))
# simultaneous path model (original)
model_mediator1o <- bf(trust_7~consp+anti + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+anti+consp|residing_country))
model_mediator2o <- bf(trust_6~consp+anti + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+anti+consp|residing_country))
model_outcomeo <- bf(vx ~ anti+consp+trust_6+trust_7 + gender + education + work_location + age+
SSS_faml+ relationship_status+ (1+trust_7+anti+trust_6+consp|residing_country))
med_result = brm(
model_mediator1 +model_mediator2 + model_outcome + set_rescor(F),
data=data.filtered,
family = gaussian(),
cores=4,chains=4, save_pars = save_pars(all = T),
sample_prior ='yes', seed=1660415,prior=prior.coef, iter=10000
)
model_mediator1 <- bf(consp~trust_6 + trust_7+ gender + education + work_location + age+
SSS_faml+ relationship_status + (1+trust_6 + trust_7|residing_country))
model_mediator2 <- bf(anti~trust_6 + trust_7 + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+trust_6 + trust_7|residing_country))
model_outcome <- bf(vx ~ anti+consp+trust_6+trust_7 + gender + education + work_location + age+
SSS_faml+ relationship_status+ (1+trust_7+anti+trust_6+consp|residing_country))
med_result = brm(
model_mediator1 +model_mediator2 + model_outcome + set_rescor(F),
data=data.filtered,
family = gaussian(),
cores=4,chains=4, save_pars = save_pars(all = T),
sample_prior ='yes', seed=1660415,prior=prior.coef, iter=10000
)
med_resulto = brm(
model_mediator1o +model_mediator2o + model_outcomeo + set_rescor(F),
data=data.filtered,
family = gaussian(),
cores=4,chains=4, save_pars = save_pars(all = T),
sample_prior ='yes', seed=1660415,prior=prior.coef, iter=10000
)
med_result
med_resulto
# model compare
bf <- bayesfactor(med_resulto,med_result)
# model compare
bf <- bayesfactor(med_result,med_resulto)
# model compare
bf <- bayesfactor(med_result,med_resulto,maxiter=10000)
mediation(med_result)
mediation(med_resulto)
# simultaneous path model
prior.coef <- brms::prior(cauchy(0.,1),class='b')
model_mediator1 <- bf(consp~trust_6 + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+trust_6 |residing_country))
model_mediator2 <- bf(anti~ trust_7 + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+ trust_7|residing_country))
model_outcome <- bf(vx ~ anti+consp+trust_6+trust_7 + gender + education + work_location + age+
SSS_faml+ relationship_status+ (1+trust_7+anti+trust_6+consp|residing_country))
# simultaneous path model (original)
model_mediator1o <- bf(trust_7~anti + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+anti|residing_country))
model_mediator2o <- bf(trust_6~consp+ gender + education + work_location + age+
SSS_faml+ relationship_status + (1+consp|residing_country))
model_outcomeo <- bf(vx ~ anti+consp+trust_6+trust_7 + gender + education + work_location + age+
SSS_faml+ relationship_status+ (1+trust_7+anti+trust_6+consp|residing_country))
med_result = brm(
model_mediator1 +model_mediator2 + model_outcome + set_rescor(F),
data=data.filtered,
family = gaussian(),
cores=4,chains=4, save_pars = save_pars(all = T),
sample_prior ='yes', seed=1660415,prior=prior.coef, iter=10000
)
med_resulto = brm(
model_mediator1o +model_mediator2o + model_outcomeo + set_rescor(F),
data=data.filtered,
family = gaussian(),
cores=4,chains=4, save_pars = save_pars(all = T),
sample_prior ='yes', seed=1660415,prior=prior.coef, iter=10000
)
med_result
med_resulto
# model compare
bf <- bayesfactor(med_result,med_resulto,maxiter=10000)
model_outcomeo
model_outcome
# Govt
# simultaneous path model
prior.coef <- brms::prior(cauchy(0.,1),class='b')
model_mediator1 <- bf(consp~trust_6 + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+trust_6 |residing_country))
model_outcome <- bf(vx ~ consp+trust_6+ gender + education + work_location + age+
SSS_faml+ relationship_status+ (1+trust_6+consp|residing_country))
# simultaneous path model (original)
model_mediator1o <- bf(trust_6~consp + gender + education + work_location + age+
SSS_faml+ relationship_status + (1+consp|residing_country))
med_result = brm(
model_mediator1  + model_outcome + set_rescor(F),
data=data.filtered,
family = gaussian(),
cores=4,chains=4, save_pars = save_pars(all = T),
sample_prior ='yes', seed=1660415,prior=prior.coef, iter=4000
)
med_resulto = brm(
model_mediator1o  + model_outcome + set_rescor(F),
data=data.filtered,
family = gaussian(),
cores=4,chains=4, save_pars = save_pars(all = T),
sample_prior ='yes', seed=1660415,prior=prior.coef, iter=4000
)
# model compare
bf <- bayesfactor(med_result,med_resulto,maxiter=10000)
med_result
med_resulto
mediation(med_result)
mediation(med_resulto)
