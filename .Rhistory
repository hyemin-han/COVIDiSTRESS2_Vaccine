# random seed
set.seed(6508420456)
# random seed
set.seed(1)
# random seed
set.seed(850110)
# first names
names<-c(
'Abdullah',
'Andrea',
'Candace',
'Delany',
'Diana',
'Elia',
'Erin',
'James',
'Kim',
'Qi',
'Sherry',
'Virginia'
)
# random order
sample(names)
# random seed
set.seed(850110)
# first names
names<-c(
'Abdullah',
'Andrea',
'Candace',
'Delany',
'Diana',
'Elia',
'Erin',
'James',
'Kim',
'Qi',
'Sherry',
'Virginia'
)
# random order
sample(names)
# random seed
set.seed(01101985)
# first names
names<-c(
'Abdullah',
'Andrea',
'Candace',
'Delany',
'Diana',
'Elia',
'Erin',
'James',
'Kim',
'Qi',
'Sherry',
'Virginia'
)
# random order
sample(names)
# random seed
set.seed(01101985)
# first names
names<-c(
'Abdullah',
'Andrea',
'Candace',
'Delany',
'Diana',
'Elia',
'Erin',
'James',
'Kim',
'Qi',
'Sherry',
'Virginia'
)
# random order
sample(names)
# random seed
set.seed(01101985)
# first names
names<-c(
'Abdullah',
'Andrea',
'Candace',
'Delany',
'Diana',
'Elia',
'Erin',
'James',
'Kim',
'Qi',
'Sherry',
'Virginia'
)
# random order
sample(names)
load("~/Documents/Documents_loaner/Research/MEP_HLM/MEP_merged.RData")
library(psych)
library(lmerTest        )
library(lmerTest        )
test.elev.3 <- lmer(Elevation ~ Attainability * Relevance + (1+Attainability+Relevance|study/ID),data=DATA,
control = lmerControl(
optimizer ='optimx', optCtrl=list(method='nlminb')),REML=F)
test.elev.3
summary(test.elev.3)
btest.elev.3  <- brms::brm(Elevation ~ Attainability * Relevance + (1+Attainability+Relevance|study/ID),
data=DATA, family = gaussian(),
cores=4,chains=4, iter=10000, save_all_pars =  TRUE,
sample_prior ='yes',prior=prior.coef,warmup=5000, seed=1660415,control = list(adapt_delta = 0.99),inits='0')
btest.elev.3
hypothesis(btest.elev.3,'Attainability:Relevance=0')
library(brms)
hypothesis(btest.elev.3,'Attainability:Relevance=0')
gc()
load("~/Documents/Documents_loaner/Research/MEP_HLM/MEP_merged.RData")
btest.plea.3
load("~/Documents/Documents_loaner/Research/MEP_HLM/MEP_merged1.RData")
bf.plea.03
btest.plea.3
summary(test.plea.3)
head(DATA)
describe(DATA)
library(psych)
describe(DATA)
class(DATA$ID)
class(DATA$Group)
class(DATA$Attainability)
class(DATA$story)
setwd("~/Documents/GitHub/COVIDiSTRESS2_Vaccine")
load("~/Documents/GitHub/COVIDiSTRESS2_Vaccine/Vaccine_aligned.RData")
library(psych)
library(lavaan)
library(sirt)
library(MASS)
#####
# 2. Conspiratorial
cfa.consp<-'
CONSP =~ conspirational_think_1 + conspirational_think_2+
conspirational_think_3 + conspirational_think_4'
# configural invariance
# DWLS preferred with 5+ categories (Christine DiStefano & Grant B. Morgan 2014)
fit.consp <- cfa(cfa.consp, data.mi, estimator = 'DWLS', group='UserLanguage')
# fit indices
fitMeasures(fit.consp)[indices]
# fit indices
fitMeasures(fit.consp)[fits]
# configural invariance
# DWLS preferred with 5+ categories (Christine DiStefano & Grant B. Morgan 2014)
fit.consp <- cfa(cfa.consp, data.mi, estimator = 'WLSMV', group='UserLanguage')
# fit indices
fitMeasures(fit.consp)[fits]
# measurement alignment test
# extract parameters
par.consp <- invariance_alignment_cfa_config(dat = data.mi[,item.consp],
group = data.mi$UserLanguage)
#####
# 2. Conspiratorial
item.consp <- c('conspirational_think_1','conspirational_think_2',
'conspirational_think_3','conspirational_think_4')
# measurement alignment test
# extract parameters
par.consp <- invariance_alignment_cfa_config(dat = data.mi[,item.consp],
group = data.mi$UserLanguage)
# do alignment
mod1.consp <- invariance.alignment(lambda = par.consp$lambda, nu =
par.consp$nu, align.scale = c(0.2, 0.4), align.pow = c(0.25, 0.25))
# test performance
mod1.consp$es.invariance['R2',]
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- data.mi[data.mi$UserLanguage==langs.include[i],]
# aligned factor score
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],item.consp])
#    F.id <- aligned.factor.scores(mod1.identity$lambda.aligned[i,],
#                                  mod1.identity$nu.aligned[i,],
#                                   data.mi[data.mi$UserLanguage==langs.include[i],items.identity])
#    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.ps])
data.aligned$vx <- t(F.vx)
data.aligned$consp <- t(F.consp)
#    data.aligned$identity <- t(F.id)
#    data.aligned$resilience <- t(F.id)
#    data.aligned$primary_stressor_avg <- t(F.ps)
}else
{
# bind
current <- data.mi[data.mi$UserLanguage==langs.include[i],]
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
current[,vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
current[,items.consp])
#    F.id <- aligned.factor.scores(mod1.identity$lambda.aligned[i,],
#                                  mod1.identity$nu.aligned[i,],
#                                   current[,items.identity])
##    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  current[,items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  current[,items.ps])
current$vx <- t(F.vx)
current$sps <- t(F.consp)
#    current$identity <- t(F.id)
#    current$resilience <- t(F.rs)
#    current$primary_stressor_avg <- t(F.ps)
data.aligned <- rbind(data.aligned,current)
}
}
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- data.mi[data.mi$UserLanguage==langs.include[i],]
# aligned factor score
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],item.consp])
#    F.id <- aligned.factor.scores(mod1.identity$lambda.aligned[i,],
#                                  mod1.identity$nu.aligned[i,],
#                                   data.mi[data.mi$UserLanguage==langs.include[i],items.identity])
#    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.ps])
data.aligned$vx <- t(F.vx)
data.aligned$consp <- t(F.consp)
#    data.aligned$identity <- t(F.id)
#    data.aligned$resilience <- t(F.id)
#    data.aligned$primary_stressor_avg <- t(F.ps)
}else
{
# bind
current <- data.mi[data.mi$UserLanguage==langs.include[i],]
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
current[,vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
current[,item.consp])
#    F.id <- aligned.factor.scores(mod1.identity$lambda.aligned[i,],
#                                  mod1.identity$nu.aligned[i,],
#                                   current[,items.identity])
##    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  current[,items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  current[,items.ps])
current$vx <- t(F.vx)
current$sps <- t(F.consp)
#    current$identity <- t(F.id)
#    current$resilience <- t(F.rs)
#    current$primary_stressor_avg <- t(F.ps)
data.aligned <- rbind(data.aligned,current)
}
}
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- data.mi[data.mi$UserLanguage==langs.include[i],]
# aligned factor score
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],item.consp])
#    F.id <- aligned.factor.scores(mod1.identity$lambda.aligned[i,],
#                                  mod1.identity$nu.aligned[i,],
#                                   data.mi[data.mi$UserLanguage==langs.include[i],items.identity])
#    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.ps])
data.aligned$vx <- t(F.vx)
data.aligned$consp <- t(F.consp)
#    data.aligned$identity <- t(F.id)
#    data.aligned$resilience <- t(F.id)
#    data.aligned$primary_stressor_avg <- t(F.ps)
}else
{
# bind
current <- data.mi[data.mi$UserLanguage==langs.include[i],]
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
current[,vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
current[,item.consp])
#    F.id <- aligned.factor.scores(mod1.identity$lambda.aligned[i,],
#                                  mod1.identity$nu.aligned[i,],
#                                   current[,items.identity])
##    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  current[,items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  current[,items.ps])
current$vx <- t(F.vx)
current$consp <- t(F.consp)
#    current$identity <- t(F.id)
#    current$resilience <- t(F.rs)
#    current$primary_stressor_avg <- t(F.ps)
data.aligned <- rbind(data.aligned,current)
}
}
# filtering by country n >= 30
country.30 <- table(data.aligned$residing_country) >= 30
n.country <- table(data.aligned$residing_country)
list.country <- labels(n.country)[[1]]
country.include <- list.country[n.country>=30]
n.include.c <- n.country[n.country>=30]
# extract data
for (i in 1:length(country.include)){
if (i == 1){
data.filtered <- data.aligned[(data.aligned$residing_country ==
country.include[i]) & !is.na(
data.aligned$residing_country
),]
}else{
current <- data.aligned[(data.aligned$residing_country == country.include[i])
& !is.na(
data.aligned$residing_country
),]
data.filtered <- rbind(data.filtered,current)
}
}
# save aligned datafile
save.image(file='Vaccine_aligned.RData')
psych::alpha(data[,item.consp],check.keys=TRUE)
corr.test(data.filtered[,c('consp','trust_6')]
)
corr.test(data.filtered[,c('consp','trust_6','trust_7')])
corr.test(data.filtered[,c('consp','trust_6','trust_7','vx')])
corr.test(data.filtered[,c('consp','trust_6','trust_7','vx','vaccine_0neutral')])
#####
# 3. Antiexpert
items.anti <- c('antiexpert_1','antiexpert_2','antiexpert_3')
cfa.model.anti <- 'ANTI =~ antiexpert_1 + antiexpert_2+antiexpert_3'
cfa.whole.anti <- cfa(model=cfa.model.anti,data=data.mi,estimator='WLSMV', group =
'UserLanguage')
fitMeasures(cfa.whole.anti)[fits]
# good. metric?
cfa.metric.anti <- cfa(model=cfa.model.anti,data=data.mi,estimator='WLSMV', group =
'UserLanguage', equal.groups='loadings')
# good. metric?
cfa.metric.anti <- cfa(model=cfa.model.anti,data=data.mi,estimator='WLSMV', group =
'UserLanguage', groups.equal='loadings')
# good. metric?
cfa.metric.anti <- cfa(model=cfa.model.anti,data=data.mi,estimator='WLSMV', group =
'UserLanguage', group.equal='loadings')
fitMeasures(cfa.metric.anti)[fits]
# measurement alignment test
# extract parameters
par.anti <- invariance_alignment_cfa_config(dat = data.mi[,items.anti],
group = data.mi$UserLanguage)
# do alignment
mod1.anti <- invariance.alignment(lambda = par.anti$lambda, nu =
par.anti$nu, align.scale = c(0.2, 0.4), align.pow = c(0.25, 0.25))
# test performance
mod1.anti$es.invariance['R2',]
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- data.mi[data.mi$UserLanguage==langs.include[i],]
# aligned factor score
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],item.consp])
F.anti <- aligned.factor.scores(mod1.anti$lambda.aligned[i,],
mod1.anti$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],items.anti])
#    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.ps])
data.aligned$vx <- t(F.vx)
data.aligned$consp <- t(F.consp)
data.aligned$anti <- t(F.anti)
#    data.aligned$resilience <- t(F.id)
#    data.aligned$primary_stressor_avg <- t(F.ps)
}else
{
# bind
current <- data.mi[data.mi$UserLanguage==langs.include[i],]
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
current[,vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
current[,item.consp])
F.id <- aligned.factor.scores(mod1.anti$lambda.aligned[i,],
mod1.anti$nu.aligned[i,],
current[,items.anti])
##    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  current[,items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  current[,items.ps])
current$vx <- t(F.vx)
current$consp <- t(F.consp)
current$anti <- t(F.anti)
#    current$resilience <- t(F.rs)
#    current$primary_stressor_avg <- t(F.ps)
data.aligned <- rbind(data.aligned,current)
}
}
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- data.mi[data.mi$UserLanguage==langs.include[i],]
# aligned factor score
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],item.consp])
F.anti <- aligned.factor.scores(mod1.anti$lambda.aligned[i,],
mod1.anti$nu.aligned[i,],
data.mi[data.mi$UserLanguage==langs.include[i],items.anti])
#    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  data.mi[data.mi$UserLanguage==langs.include[i],items.ps])
data.aligned$vx <- t(F.vx)
data.aligned$consp <- t(F.consp)
data.aligned$anti <- t(F.anti)
#    data.aligned$resilience <- t(F.id)
#    data.aligned$primary_stressor_avg <- t(F.ps)
}else
{
# bind
current <- data.mi[data.mi$UserLanguage==langs.include[i],]
F.vx <- aligned.factor.scores(mod1.vx$lambda.aligned[i,],
mod1.vx$nu.aligned[i,],
current[,vaxs])
F.consp <- aligned.factor.scores(mod1.consp$lambda.aligned[i,],
mod1.consp$nu.aligned[i,],
current[,item.consp])
F.anti <- aligned.factor.scores(mod1.anti$lambda.aligned[i,],
mod1.anti$nu.aligned[i,],
current[,items.anti])
##    F.rs <- aligned.factor.scores(mod1.resilience$lambda.aligned[i,],
#                                  mod1.resilience$nu.aligned[i,],
#                                  current[,items.resilience])
#    F.ps <- aligned.factor.scores(mod1.ps$lambda.aligned[i,],
#                                  mod1.ps$nu.aligned[i,],
#                                  current[,items.ps])
current$vx <- t(F.vx)
current$consp <- t(F.consp)
current$anti <- t(F.anti)
#    current$resilience <- t(F.rs)
#    current$primary_stressor_avg <- t(F.ps)
data.aligned <- rbind(data.aligned,current)
}
}
# filtering by country n >= 30
country.30 <- table(data.aligned$residing_country) >= 30
n.country <- table(data.aligned$residing_country)
list.country <- labels(n.country)[[1]]
country.include <- list.country[n.country>=30]
n.include.c <- n.country[n.country>=30]
# extract data
for (i in 1:length(country.include)){
if (i == 1){
data.filtered <- data.aligned[(data.aligned$residing_country ==
country.include[i]) & !is.na(
data.aligned$residing_country
),]
}else{
current <- data.aligned[(data.aligned$residing_country == country.include[i])
& !is.na(
data.aligned$residing_country
),]
data.filtered <- rbind(data.filtered,current)
}
}
# save aligned datafile
save.image(file='Vaccine_aligned.RData')
psych::alpha(data[,items.anti],check.keys=TRUE)
corr.test(data.filtered[])
corr.test(data.filtered[,c('vx','consp','anti','trust_6','trust_7','vaccine_0neutral')])
